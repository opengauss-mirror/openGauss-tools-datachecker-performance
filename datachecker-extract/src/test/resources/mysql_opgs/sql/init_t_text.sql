use test_schema;

DROP TABLE IF EXISTS `t_text`;
CREATE TABLE IF NOT EXISTS `t_text` (
  `id` int(11) NOT NULL,
  `c_tinytext` tinytext,
  `c_text` text,
  `c_mediumtext` mediumtext,
  `c_longtext` longtext,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO `t_text` (`id`, `c_tinytext`, `c_text`, `c_mediumtext`, `c_longtext`) VALUES (1, 'we could do one of two thingstrying to test an applicatio', 'communicates with other services then we could do one of', 'other services then we could do one of two thingstrying to test an application that communicates with other services then we could do one of two thingstrying', 'application that communicates with other services then we could do one of two thingstrying to test');
INSERT INTO `t_text` (`id`, `c_tinytext`, `c_text`, `c_mediumtext`, `c_longtext`) VALUES (2, NULL, NULL, NULL, NULL);
INSERT INTO `t_text` (`id`, `c_tinytext`, `c_text`, `c_mediumtext`, `c_longtext`) VALUES (3, ' ', ' ', ' ', ' ');
INSERT INTO `t_text` (`id`, `c_tinytext`, `c_text`, `c_mediumtext`, `c_longtext`) VALUES (4, 'mysql text 类型 MySQL中的TEXT数据类型是一种用于存储大规模文本数据的结构。与CHAR和VARCHAR字符类型不同，TEXT类型允许存储从1字节到4GB长度的文本字符串，而不需要预先指定固定长度。此外，TEXT', '\r\nmysql text 类型\r\nMySQL中的TEXT数据类型是一种用于存储大规模文本数据的结构。与CHAR和VARCHAR字符类型不同，TEXT类型允许存储从1字节到4GB长度的文本字符串，而不需要预先指定固定长度。此外，TEXT列在插入或检索时会保留所有存储的字符，包括空格，这不同于CHAR和VARCHAR列，后者会在插入或检索时处理空格。\r\n\r\nTEXT数据类型支持多种字符集，并且可以根据需要调整存储效率。在使用TEXT类型时，通常需要在创建表时明确指定列的数据类型。例如，以下是在创建新表时使用TEXT类型的例子：\r\n\r\n```sql\r\n\r\nCREATE TABLE articles (\r\n\r\nid INT AUTO_INCREMENT PRIMARY KEY,\r\n\r\ntitle VARCHAR(255),\r\n\r\nsummary TEXT\r\n\r\n);\r\n\r\n```\r\n\r\nTEXT类型可以被分为四个子类别：\r\n\r\nTINYTEXT：1个字节（255个字符）\r\nTEXT：64KB（65,535个字符）\r\nMEDIUMTEXT：16MB（16,777,215个字符）\r\nLONGTEXT：最大容量（理论上可达4GB），但实际使用时应避免过大以防止性能问题\r\n在实际应用中，TEXT类型常用于存储文章的正文、产品详细描述或其他需要存储较长文本的消息。需要注意的是，TEXT数据不是保存在数据库服务器内存中的，而是必须从磁盘加载到内存中进行访问，这使得查询TEXT数据的速度相对较慢。\r\n\r\n总结来说，TEXT类型在MySQL中是用于存储海量文本信息的灵活且功能强大的工具。', 'MySQL的text和longtext类型详解\r\nHBLOG 2023-11-28 09:05 发表于北京\r\nMySQL中的text和longtext类型是常用的字符串类型，可以储存大量文本数据。text类型可以存储最大长度为65535个字符的字符串，而longtext类型可以存储最大长度为4294967295个字符的字符串。本文将从多个方面对这两种数据类型进行详细的阐述。\r\n\r\n一、text和longtext的特点\r\ntext和longtext类型的最大值取决于数据存储引擎，这是因为不同的存储引擎有不同的限制。例如，对于InnoDB引擎，text和longtext类型最大值为65535和4294967295个字符，而对于MyISAM引擎，text和longtext类型最大值为65535和4294967295个字节，按照UTF-8编码时，最大长度则为65533和4294967263。除了存储限制之外，text和longtext类型还有以下特点：1、支持像varchar和char类型一样的索引和排序操作。2、可以通过BLOB和TEXT参数来指定偏好存储在磁盘上。3、可能需要额外的磁盘空间来存储大量的文本数据，因此需要合理使用。\r\n\r\n二、使用text和longtext类型的注意事项\r\n当我们使用text和longtext类型储存数据时，需要注意以下几点：\r\n\r\n1、插入数据错误\r\n当我们插入的数据长度超过text或longtext类型的最大值时，会导致插入数据错误。此时可将数据分段插入，或使用BLOB类型（需要将数据编码为十六进制字符串）来存储。\r\n\r\n2、数据类型转换错误\r\n当我们使用text或longtext类型与其他类型进行计算时，可能会发生数据类型转换错误。例如，将text字符串与数字相加会导致text字符串转换为数字失败。\r\n\r\n3、导致查询效率降低\r\n如果我们使用text或longtext类型来保存索引列，那么查询效率会受到很大影响。因此，在设计表结构时，需要考虑特定列的数据类型和使用情况，以充分利用索引，提高查询效率。\r\n\r\n三、使用示例\r\n下面是text和longtext类型的使用示例：\r\n\r\nCREATE TABLE example_text (\r\n id INT UNSIGNED AUTO_INCREMENT,\r\n content TEXT,\r\n PRIMARY KEY (id)\r\n);\r\n \r\nINSERT INTO example_text (content) VALUES (\'这是一段text类型的数据\');\r\nINSERT INTO example_text (content) VALUES (\'这是另一段text类型的数据\');\r\n \r\nSELECT * FROM example_text WHERE content LIKE \'%text类型%\';\r\n另一个示例：\r\n\r\nCREATE TABLE example_longtext (\r\n id INT UNSIGNED AUTO_INCREMENT,\r\n content LONGTEXT,\r\n PRIMARY KEY (id)\r\n);\r\n \r\nINSERT INTO example_longtext (content) VALUES (\'这是一段longtext类型的数据\');\r\nINSERT INTO example_longtext (content) VALUES (\'这是另一段longtext类型的数据\');\r\n \r\nSELECT * FROM example_longtext WHERE content LIKE \'%longtext类型%\';\r\n\r\n四、总结\r\n在MySQL中，text和longtext类型是用于储存大量文本数据的常用字符串类型。虽然使用时需要注意一些细节和限制，但是这两种类型的灵活性和可扩展性使得它们在数据储存中发挥着重要的作用。\r\n\r\n', 'MySQL中的Text类型：MySQL Text, MediumText类型用法介绍\r\n更新：2023-06-10 06:29\r\n一、概述\r\nMySQL中的文本类型是一种非常重要的数据类型，可以存储大块的文本数据，文本类型包括：varchar、text、mediumtext、longtext、blob、mediumblob、longblob等。本文将着重探究MySQL中的text和mediumtext类型，深入了解其特性和使用场景。\r\n\r\n二、MySQL中的Text类型\r\n1、Text类型介绍\r\n在MySQL中，text数据类型用于存储非常长的文本字符串。text类型通常应用于存储博客、文章、日志、评论等大块文本数据。\r\n\r\nText类型有四种，分别为：TinyText、Text、Mediumtext、Longtext。\r\n\r\n分别可以存储不同长度的文本：\r\n\r\nTinytext：最大长度为255个字符；\r\nText: 最大长度为65,535个字符；\r\nMediumtext: 最大长度为16,777,215个字符；\r\nLongtext: 最大长度为4,294,967,295个字符。\r\n2、Text类型特点\r\nText类型最大的特点就是可以存储大块的文本，而且存储的文本不会被截断。而且，Text类型支持中文等特殊字符，能够存储绝大部分的字符集。\r\n\r\n3、Text类型注意事项\r\n由于Text类型存储的数据量较大，因此在进行数据库查询时，由于文本在内存中需要缓存起来，所以会增加系统的开销。同时，也需要定期对文本数据进行维护，以避免MySQL数据文件的过度膨胀问题。\r\n\r\n三、MySQL中的Mediumtext类型\r\n1、Mediumtext类型介绍\r\n与Text类型类似，MySQL中的Mediumtext类型用于存储一定数量的字符数据。相比Text类型，Mediumtext类型支持存储更大的文本数据，最大可存储16,777,215个字符；同时Mediumtext类型也比Text类型更加节省存储空间，因为Mediumtext类型存储时，它不需要因为默认编码而进行填充操作，所以存储的空间会更小。\r\n\r\n2、Mediumtext类型特点\r\nMediumtext类型支持Unicode字符集（包括UTF-8、UCS-2和UCS-4等）。Mediumtext类型还支持2GB以上的空间，也可以存储二进制数据。\r\n\r\n3、Mediumtext类型注意事项\r\nMySQL中的Mediumtext类型可用于存储文本内容相关的值，例如存储HTML、XML、JSON、CSV等。不过，Mediumtext类型在存储前还是需要进行检查，以确保存储的内容不会超过其限制。\r\n\r\n四、完整代码示例\r\n1、创建一张test表\r\nCREATE TABLE `test` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `text` text NOT NULL,\r\n  `mediumtext` mediumtext NOT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\r\n2、插入数据到test表中\r\nINSERT INTO `test` (`text`, `mediumtext`) VALUES (\'这是一段text类型的数据,最大支持65535个字符。在此之后请使用mediumtext类型\', \'这是一段mediumtext类型的数据，长度最大可达到16,777,215 个字符。\');\r\n3、查询数据\r\nSELECT * FROM `test`;\r\n4、删除test表\r\nDROP TABLE `test`;\r\n五、总结\r\n通过以上的介绍，我们可以了解到MySQL中的Text类型和Mediumtext类型的特点和使用场景。在实际应用中，我们需要考虑到数据存储、查询和维护的复杂性，合理选择数据类型来保证应用的效率和稳定性。');
INSERT INTO `t_text` (`id`, `c_tinytext`, `c_text`, `c_mediumtext`, `c_longtext`) VALUES (5, 'MySQL text type\r\n\r\nThe text data type in MySQL is a structure used to store large-scale text data. Unlike the CHAR and VARCHAR character types, the XT type allows storing text strings ranging in length from 1 byte to 4GB without specifying a fixed length ', 'MySQL text type\nThe text data type in MySQL is a structure used to store large-scale text data. Unlike the CHAR and VARCHAR character types, the XT type allows storing text strings ranging in length from 1 byte to 4GB without specifying a fixed length in advance. In addition, the XT column preserves all stored characters, including spaces, during insertion or retrieval, unlike the CHAR and VARCHAR columns, which handle spaces during insertion or retrieval.\nThe text data type supports multiple character sets and can adjust storage efficiency as needed. When using the text type, it is usually necessary to explicitly specify the data type of the column when creating the table. For example, the following is an example of using the TYPE type when creating a new table:\n```SQL\nCREATE Table articles（\nID INT AUTO_ INCREMENT PRIMARY KEY,\nTitle VARCHAR (255),\nSummary Text\n）;\n```\nThe text type can be divided into four subcategories:\nTINYTEXT: 1 byte (255 characters)\nText: 64KB (65535 characters)\nMEDIUMTEST: 16MB (16777215 characters)\nLONGEXT: Maximum capacity (theoretically up to 4GB), but excessive capacity should be avoided during actual use to prevent performance issues\nIn practical applications, the text type is commonly used to store the main text of an article, detailed product descriptions, or other messages that require storing longer text. It should be noted that the text data is not stored in the memory of the database server, but must be loaded from disk to memory for access, which makes querying text data relatively slow.\nIn summary, the Text type is a flexible and powerful tool in MySQL for storing massive amounts of text information.', 'Skip to content\r\nProducts\r\nSolutions\r\nResources\r\n\r\nDocumentation\r\nPricing\r\nContact\r\n\r\nSign in\r\nGet started\r\nBlog\r\nTutorials\r\nFollow us\r\nBuild a contacts app with Node, Express, and MySQL\r\nLearn how to build a contacts web app with Node, Express, and PlanetScale.\r\n\r\nBuild a contacts app with Node, Express, and MySQL\r\nThe database is an essential component of every application as it provides the requisite data for the application to function and must be a primary consideration when designing/implementing an application. Another important consideration is whether to render the application on the client\'s browser or the application server. By taking advantage of the faster load time SSR (Server Side Rendering) provides, your application can serve your users even better.\r\n\r\nIn this article, I will show you how to implement SSR using Express and Pug. PlanetScale will provide the database service - allowing you to enjoy all the benefits of MySQL via a highly scalable and reliable service provider, while Prisma will be used as an ORM (Object Relational Mapping) tool. To keep things simple, you will focus on creating basic features for managing customer data and rendering the user interface using Pug templates.\r\n\r\nGetting Started\r\nSetting up PlanetScale Database\r\nWith PlanetScale, you can either create a new database via the dashboard or the pscale CLI. Whichever you choose to use is a matter of preference. While this article will show you the steps via the dashboard, the corresponding CLI command will be shown below. Note that whichever route you choose, you have to be logged in. The command to login via the CLI is shown below.\r\n\r\nTerminal\r\n\r\npscale auth login\r\nTo complete the CLI authentication process, a confirmation page will be opened in your browser. Confirm that the displayed code matches the one displayed in your terminal by clicking Confirm code.\r\n\r\nHaving done that, you can proceed with creating a new database.\r\n\r\nCreate a database via the dashboard\r\nGo to the PlanetScale dashboard and click "New database" > "Create new database". You\'ll be presented with a page to name your database, select a region, and choose a plan.\r\n\r\nGive your database a name and select the region closest to you or your application. For this tutorial, we will name the database express_crm_db and use the default region. Select your desired plan, then click “Create database” to complete the creation process. You will be redirected to the database dashboard as shown below.\r\n\r\nView database\r\n\r\nNext, you need the database credentials. To get them, click the “Get connection strings” button on the right side of the dashboard. This shows you the database authentication credentials as well as a sample code for connecting to your database for different programming languages.\r\n\r\nDatabase credentials\r\n\r\nCreate a database via CLI\r\nTo create a new database via the CLI, use the following command.\r\n\r\nTerminal\r\n\r\npscale db create express_crm_db\r\nNext, set up the credentials via the CLI using the following command.\r\n\r\nTerminal\r\n\r\npscale password create express_crm_db main express-app\r\nA table with the following values will be displayed once the process is completed.\r\n\r\nTerminal\r\n\r\nNAME  BRANCH   ID   USERNAME   ACCESS HOST URL   ROLE  ROLE DESCRIPTION  PASSWORD\r\nMake a note of these values as they are only shown once. In particular, you will require USERNAME, PASSWORD, and ACCESS HOST URL.\r\n\r\nCopy the database credentials and keep them handy as you will need them when you start building the application. For security, these details are only displayed once and if you lose your credentials, you will need to generate a new set.\r\n\r\nNow we have everything we need to build and connect our application to our database.\r\n\r\nSet up application\r\nTo get started, create a new project folder and navigate into it. You can do it with the following command.\r\n\r\nTerminal\r\n\r\nmkdir express_crm && cd $_\r\nNext, issue the following command to initialize the project, generate and populate package.json file\r\n\r\nTerminal\r\n\r\nnpm init -y\r\nAlso, use the following command to add the dev dependencies to the project.\r\n\r\nTerminal\r\n\r\nnpm install concurrently nodemon prisma @prisma/client typescript ts-node @types/node --save-dev\r\nNow initialize TypeScript using the following command.\r\n\r\nTerminal\r\n\r\nnpx tsc --init\r\nA new file named tsconfig.json will be created containing the default TypeScript configuration. Open it and modify the code to match the following.\r\n\r\nJSON\r\n\r\n{\r\n  "compilerOptions": {\r\n    "target": "es2016",\r\n    "module": "commonjs",\r\n    "esModuleInterop": true,\r\n    "forceConsistentCasingInFileNames": true,\r\n    "rootDir": "./",\r\n    "outDir": "./dist"\r\n  }\r\n}\r\nNext, add the following dev entry to the scripts object in package.json. This will simplify the process of building and running the application.\r\n\r\nJSON\r\n\r\n  "scripts": {\r\n    "dev": "concurrently \\"npx tsc --watch\\" \\"nodemon -q dist/app.js\\""\r\n  }\r\nWith this script, you can run npm run dev start your application and watch your .ts files. When changes are detected, the project will automatically be rebuilt and restarted with the latest version of your code.\r\n\r\nConnect the application to PlanetScale\r\nPrisma will be used to handle interactions with the PlanetScale database. To get started, run the following command.\r\n\r\nTerminal\r\n\r\nnpx prisma init\r\nThis command does two things. First, it creates a .env file that will hold environment variables for the application such as the database URL. It also creates a schema file named schema.prisma in a directory named prisma. This file contains everything database-related (including the database models). Open it and update it to match the following.\r\n\r\nPrisma\r\n\r\ngenerator client {\r\n  provider = "prisma-client-js"\r\n}\r\n\r\n\r\ndatasource db {\r\n  provider     = "mysql"\r\n  url          = env("DATABASE_URL")\r\n  relationMode = "prisma"\r\n}\r\n\r\n\r\nmodel Client {\r\n  id             Int             @id @default(autoincrement())\r\n  name           String          @db.VarChar(255)\r\n  isCorporate    Boolean         @default(false)\r\n  yearFounded    String          @db.VarChar(255)\r\n  primaryContact PrimaryContact?\r\n}\r\n\r\n\r\nmodel PrimaryContact {\r\n  id           Int    @id @default(autoincrement())\r\n  name         String @db.VarChar(255)\r\n  phoneNumber  String @db.VarChar(255)\r\n  emailAddress String @db.VarChar(255)\r\n  client       Client @relation(fields: [clientId], references: [id], onDelete: Cascade)\r\n  clientId     Int    @unique\r\n}\r\nThis schema declares two models: Client and PrimaryContact. Both models have a one-to-one relationship.\r\n\r\nThe datasource is also declared. The provider is set to mysql since PlanetScale is based on MySQL. The DATABASE_URL is retrieved from the .env file which we will update shortly. The last line specifies prisma as the relation mode. This prevents Prisma from adding foreign key constraints, which are unsupported by PlanetScale.\r\n\r\nNext, open the newly created .env file and add the following.\r\n\r\nTerminal\r\n\r\nDATABASE_URL=\'mysql://<USERNAME>:<PASSWORD>@<ACCESS_HOST_URL>/express_crm_db?sslcert=/etc/ssl/cert.pem\'\r\nAPP_PORT=8000\r\nThe APP_PORT variable will be used later in the application to listen for, and handle requests.\r\n\r\nThe DATABASE_URL is the environment variable used by Prisma for connecting to the database. An sslCert query is added to ensure that the connection is SSL secured.\r\n\r\nNote\r\nThe value for sslcert query will depend on your system. You can find more information on our Secure Connections page.\r\n\r\nWith these changes in place, update your database schema using the following command.\r\n\r\nTerminal\r\n\r\nnpx prisma db push\r\nAdditionally, this command reads your Prisma schema and generates a version of Prisma Client that is tailored to the models you declared earlier.\r\n\r\nSet up Express\r\nNext install run the following command to install the necessary packages to enable this project as a web application:\r\n\r\nTerminal\r\n\r\nnpm install dotenv express express-validator pug\r\nYou also need to add @types/express as a dev dependency:\r\n\r\nTerminal\r\n\r\nnpm install @types/express --save-dev\r\nNext, create a new folder named views at the root of the project folder. This folder will hold all the Pug templates to be rendered by the application.\r\n\r\nCreate a new file named base.pug in the views directory. This is the base template and will have blocks which will contain content specific to pages that utilize the template. The base template will contain the aspects of the application that is common across all pages like includes styling, head content, and scripts. Add the following to views/base.pug.\r\n\r\nPug\r\n\r\nblock variables\r\ndoctype html\r\nhtml\r\n  head\r\n    meta(charset="utf-8")\r\n    link(rel="shortcut icon", href="https://planetscale.com/favicon.svg")\r\n    link(rel="shortcut icon", href="https://planetscale.com/favicon.ico")\r\n    meta(\r\n      name="viewport",\r\n      content="width=device-width, initial-scale=1, shrink-to-fit=no"\r\n    )\r\n    meta(name="theme-color", content="#000000")\r\n    title #{ title } | PlanetScale CRM\r\n    link(\r\n      rel="stylesheet",\r\n      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css",\r\n      integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC",\r\n      crossorigin="anonymous"\r\n    )\r\n    link(\r\n      rel="stylesheet",\r\n      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css"\r\n    )\r\n\r\n\r\n  body\r\n    #root(style="margin: 2%")\r\n      nav.navbar.navbar-expand-sm.navbar-light.bg-light\r\n        .container-fluid\r\n          a.navbar-brand(href="/clients") Express CRM\r\n          button.navbar-toggler(\r\n            type="button",\r\n            data-bs-toggle="collapse",\r\n            data-bs-target="#navbarCollapse"\r\n          )\r\n            span.navbar-toggler-icon\r\n          #navbarCollapse.collapse.navbar-collapse\r\n            ul.nav.navbar-nav.ms-auto\r\n              li.nav-item.dropdown\r\n                a.nav-link.dropdown-toggle(href="#", data-bs-toggle="dropdown") Clients\r\n                .dropdown-menu.dropdown-menu-end\r\n                  a.dropdown-item(href="/clients") View All\r\n                  a.dropdown-item(href="/client/create") Add New\r\n\r\n\r\n      block layout-content\r\n    script(\r\n      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js",\r\n      integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM",\r\n      crossorigin="anonymous"\r\n    )\r\nNext, create a new file named index.pug in the views folder to be the index page of the application. Add the following to it:\r\n\r\nPug\r\n\r\nextends base\r\n\r\n\r\nblock layout-content\r\n  h1= message\r\nNext, create an entry point for your application. At the root of the project folder, create a new file named app.ts and add the following code to it:\r\n\r\nTypeScript\r\n\r\nimport express from \'express\'\r\nimport * as dotenv from \'dotenv\'\r\n\r\n\r\ndotenv.config()\r\n\r\n\r\n// Create a new Express app\r\nconst app = express()\r\n\r\n\r\napp.set(\'views\', \'./views\')\r\napp.set(\'view engine\', \'pug\')\r\n\r\n\r\n// declare an index route\r\napp.get(\'/\', (req, res) => {\r\n  res.render(\'index\', { title: \'Hey\', message: \'Hello, World ✌️\' })\r\n})\r\n\r\n\r\nconst { APP_PORT: port } = process.env || 8000\r\n\r\n\r\n// Listen for request on specified ports\r\napp.listen(port, () => console.log(`Server started on port ${port}`))\r\nWhat you have done so far is:\r\n\r\nLoad environment variables using dotenv\r\nCreate a new Express app\r\nSet the directory containing the application views\r\nSet the application’s view engine\r\nDeclare an index route which will render the index.pug template you created earlier.\r\nListen for requests - either on the port specified in .env or port 8000\r\nStart the application using the following command.\r\n\r\nTerminal\r\n\r\nnpm run dev\r\nOpen the application in your browser to see your index page.\r\n\r\nApplication homepage\r\n\r\nForm validation\r\nThe next thing you’ll handle is validation. To add new clients, the user will fill out a form. However, it is important to ensure that the user isn’t filling in incorrect (or even dangerous) data. To do this, the submitted form must be validated before saving the data to the database. You’ve already added express-validator to your project, with that, you can create a middleware function to validate the user input and return errors if any.\r\n\r\nTo do this, create a new folder named utility at the root of the project folder. In this folder, create a new file named validator.ts and add the following code to it.\r\n\r\nTypeScript\r\n\r\nimport { body } from \'express-validator\'\r\n\r\n\r\nexport const clientInputCheck = () => [\r\n  body(\'clientName\').trim().not().isEmpty().withMessage("Please provide the client\'s name"),\r\n  body(\'isCorporate\').trim().isIn([\'on\', \'\']),\r\n  body(\'yearFounded\')\r\n    .trim()\r\n    .not()\r\n    .isEmpty()\r\n    .withMessage(\'Year founded cannot be empty\')\r\n    .isInt()\r\n    .withMessage(\'Please enter a valid year\'),\r\n  body(\'contactName\').trim().not().isEmpty().withMessage("Please provide the primary contact\'s name"),\r\n  body(\'contactPhoneNumber\')\r\n    .trim()\r\n    .not()\r\n    .isEmpty()\r\n    .withMessage("Please provide the primary contact\'s phone number")\r\n    .isLength({\r\n      min: 11,\r\n      max: 11\r\n    })\r\n    .withMessage(\'Please provide a valid phone number with not less than or more than 11 digits\'),\r\n  body(\'contactEmailAddress\')\r\n    .trim()\r\n    .not()\r\n    .isEmpty()\r\n    .withMessage("Please provide the primary contact\'s email address")\r\n    .isEmail()\r\n    .withMessage(\'Please enter a valid email address\')\r\n]\r\n\r\n\r\nexport interface ErrorResponse {\r\n  type: string\r\n  value: string\r\n  msg: string\r\n  path: string\r\n  location: string\r\n}\r\n\r\n\r\nexport const formatErrorResponse = (input: ErrorResponse[]) => {\r\n  return input.reduce((accumulator, currentItem) => {\r\n    accumulator[currentItem.path] = currentItem.msg\r\n    return accumulator\r\n  }, {})\r\n}\r\nThe clientInputCheck function returns an array of validation rules built using the body function - one for each field in the client form.\r\n\r\nNext, an interface named ErrorResponse is declared. This matches the content of the error object generated by express-validator if the user input for a field violates the corresponding rule.\r\n\r\nFinally, a function named formatErrorResponse is declared which takes an array of ErrorResponse objects and reduces them to a single object. This object is used by the Pug template to provide feedback to the user as to the nature of the invalid input.\r\n\r\nController functions\r\nNext, write the functions that will handle client-related requests. For this tutorial, you will have four such functions:\r\n\r\nAn index function that renders all the clients\r\nA create function that renders the form for adding a new client\r\nA store function that handles the submitted form, and saves the new client if the submitted form is valid. If the form is invalid, then the form is re-rendered with appropriate error messages displayed. For this article, all form validations will be handled server-side.\r\nA destroy function that deletes a client from the database.\r\nCreate a new folder named controllers at the root of the project folder and in it a new file named client.ts. Add the following code to controllers/client.ts.\r\n\r\nTypeScript\r\n\r\nimport { validationResult } from \'express-validator\'\r\nimport { ErrorResponse, formatErrorResponse } from \'../utility/validator\'\r\nimport { PrismaClient } from \'@prisma/client\'\r\n\r\n\r\nconst prisma = new PrismaClient()\r\n\r\n\r\nexport const index = async (req, res) => {\r\n  const clients = await prisma.client.findMany({\r\n    include: { primaryContact: true }\r\n  })\r\n  res.render(\'clients/index\', { title: \'All Clients\', clients })\r\n}\r\n\r\n\r\nexport const create = (req, res) => {\r\n  res.render(\'clients/create\', { title: \'New Client\' })\r\n}\r\n\r\n\r\nexport const store = async (req, res) => {\r\n  let errors = validationResult(req)\r\n  if (!errors.isEmpty()) {\r\n    const errorResponse = formatErrorResponse(errors.array() as ErrorResponse[])\r\n    res.render(\'clients/create\', {\r\n      title: \'New Client\',\r\n      errors: errorResponse,\r\n      values: req.body\r\n    })\r\n  } else {\r\n    const {\r\n      clientName: name,\r\n      isCorporate,\r\n      yearFounded,\r\n      contactName,\r\n      contactPhoneNumber,\r\n      contactEmailAddress\r\n    } = req.body\r\n\r\n\r\n    await prisma.client.create({\r\n      data: {\r\n        name,\r\n        isCorporate: isCorporate === \'on\',\r\n        yearFounded,\r\n        primaryContact: {\r\n          create: {\r\n            name: contactName,\r\n            phoneNumber: contactPhoneNumber,\r\n            emailAddress: contactEmailAddress\r\n          }\r\n        }\r\n      }\r\n    })\r\n\r\n\r\n    res.redirect(\'/clients\')\r\n  }\r\n}\r\n\r\n\r\nexport const destroy = async (req, res) => {\r\n  const { id } = req.params\r\n  await prisma.client.delete({\r\n    where: {\r\n      id: +id\r\n    }\r\n  })\r\n  res.redirect(\'/clients\')\r\n}\r\nUsing Prisma, the index function retrieves all the clients in the PlanetScale database and passes it as a template variable to the Pug template.\r\n\r\nThe store function checks for errors in the request using the validationResult function provided by express-validator. If there are any errors, they are formatted using the formatErrorResponse function declared earlier and passed as a variable to the template responsible for rendering the client form. The submitted values are also returned - this saves the user the stress of having to re-type everything. If there are no errors, then a new client is created via the Prisma create function, and the user is redirected to the list of all clients.\r\n\r\nThe destroy function retrieves the id from the request parameters and makes the appropriate Prisma delete call.\r\n\r\nAdd views for client pages\r\nNext, you\'ll add two views for the client pages: one to show all the clients, and another to show the Add Client form. In the views folder, create a new folder named clients. In the clients folder, create two new files named create.pug and index.pug.\r\n\r\nOpen views/clients/index.pug and add the following code to it.\r\n\r\nPug\r\n\r\nextends ../base\r\n\r\n\r\nblock layout-content\r\n  .container(style="margin-top: 5%")\r\n    h1 All Clients\r\n    table.table.table-bordered.table-striped.table-hover\r\n      thead\r\n        tr\r\n          th.text-center(scope="col")\r\n          th.text-center(scope="col", colspan=2) Client\r\n          th.text-center(scope="col", colspan=3) Primary Contact\r\n          th.text-center(scope="col")\r\n\r\n\r\n        tr\r\n          th.text-center(scope="col") #\r\n          th.text-center(scope="col") Name\r\n          th.text-center(scope="col") Year Founded\r\n          th.text-center(scope="col") Name\r\n          th.text-center(scope="col") Phone Number\r\n          th.text-center(scope="col") Email Address\r\n          th.text-center(scope="col") Actions\r\n      tbody\r\n        each client, index in clients\r\n          tr\r\n            td.text-center= index + 1\r\n            td.text-center= client.name\r\n            td.text-center= client.yearFounded\r\n            td.text-center= client.primaryContact.name\r\n            td.text-center= client.primaryContact.phoneNumber\r\n            td.text-center= client.primaryContact.emailAddress\r\n            td.text-center(style="vertical-align: top; padding: 0px")\r\n              form(method="POST", action="client/delete/" + client.id)\r\n                button.btn\r\n                  i.bi.bi-trash3.text-danger(style="font-size: 1.3rem")\r\nThis template takes the list of clients and renders them in a table - one row for each client. Additionally, it adds a button on each row which the user can click to delete the client.\r\n\r\nNext, add the following code to views/clients/create.pug.\r\n\r\nPug\r\n\r\nextends ../base\r\n\r\n\r\nblock layout-content\r\n  .container(style="width: 80%; margin: auto; margin-top: 5%")\r\n    h1 Add New Client\r\n    form.row.g-3.needs-validation(\r\n      action="/client",\r\n      method="POST",\r\n      novalidate=""\r\n    )\r\n      .col-md-8\r\n        label.form-label(for="clientName") Client Name\r\n        input#clientName.form-control(\r\n          type="text",\r\n          placeholder="Client Name",\r\n          name="clientName",\r\n          class=errors && errors.clientName ? "is-invalid" : "",\r\n          value=values ? values.clientName : ""\r\n        )\r\n        if errors\r\n          .invalid-feedback= errors.clientName\r\n      .col-md-4\r\n        label.form-label(for="yearFounded") Year Founded\r\n        input#yearFounded.form-control(\r\n          type="text",\r\n          placeholder="Year founded",\r\n          name="yearFounded",\r\n          class=errors && errors.yearFounded ? "is-invalid" : "",\r\n          value=values ? values.yearFounded : ""\r\n        )\r\n        if errors\r\n          .invalid-feedback= errors.yearFounded\r\n\r\n\r\n      .col-md-4.form-check\r\n        input#isCorporate.form-check-input(\r\n          type="checkbox",\r\n          name="isCorporate",\r\n          checked=values ? values.isCorporate == "on" : false\r\n        )\r\n        label.form-check-label(for="isCorporate") Client is corporate\r\n\r\n\r\n      h3.my-3 Primary Contact\r\n      .col-md-4\r\n        label.form-label(for="contactName") Contact Name\r\n        input#contactName.form-control(\r\n          type="text",\r\n          placeholder="Contact Name",\r\n          name="contactName",\r\n          class=errors && errors.contactName ? "is-invalid" : "",\r\n          value=values ? values.contactName : ""\r\n        )\r\n        if errors\r\n          .invalid-feedback= errors.contactName\r\n\r\n\r\n      .col-md-4\r\n        label.form-label(for="contactPhoneNumber") Phone Number\r\n        input#contactPhoneNumber.form-control(\r\n          type="text",\r\n          placeholder="Phone Number",\r\n          name="contactPhoneNumber",\r\n          class=errors && errors.contactPhoneNumber ? "is-invalid" : "",\r\n          value=values ? values.contactPhoneNumber : ""\r\n        )\r\n        if errors\r\n          .invalid-feedback= errors.contactPhoneNumber\r\n\r\n\r\n      .col-md-4\r\n        label.form-label(for="contactEmailAddress") Email Address\r\n        input#contactEmailAddress.form-control(\r\n          type="email",\r\n          placeholder="Email Address",\r\n          name="contactEmailAddress",\r\n          class=errors && errors.contactEmailAddress ? "is-invalid" : "",\r\n          value=values ? values.contactEmailAddress : ""\r\n        )\r\n        if errors\r\n          .invalid-feedback= errors.contactEmailAddress\r\n      .col-12\r\n        button.btn.btn-primary(type="submit") Submit\r\nThis template renders the form for adding a new client. In addition to declaring the fields of the form, the template checks if the errors variable is set, and styles each field in the form accordingly in the event that there are errors. It also checks if the values variable is present and adds each value to its proper field in the form if it is.\r\n\r\nUpdate app.ts\r\nWith everything in place, all that is left to do is update the entry point of the application - app.ts to include the new routes for the controller functions, as well as the appropriate middleware to parse the body of the request. Open app.ts and update the code to match the following.\r\n\r\nTypeScript\r\n\r\nimport express from \'express\'\r\nimport * as dotenv from \'dotenv\'\r\nimport { create, destroy, index, store } from \'./controllers/client\'\r\nimport bodyParser from \'body-parser\'\r\nimport { clientInputCheck } from \'./utility/validator\'\r\n\r\n\r\ndotenv.config()\r\n\r\n\r\nconst app = express()\r\n\r\n\r\napp.use(bodyParser.urlencoded({ extended: true }))\r\n\r\n\r\napp.set(\'views\', \'./views\')\r\napp.set(\'view engine\', \'pug\')\r\n\r\n\r\napp.get(\'/\', (req, res) => {\r\n  res.render(\'index\', { title: \'Hey\', message: \'Hello, World ✌️\' })\r\n})\r\n\r\n\r\napp.get(\'/clients\', index)\r\napp.get(\'/client/create\', create)\r\napp.post(\'/client\', clientInputCheck(), store)\r\napp.post(\'/client/delete/:id\', destroy)\r\n\r\n\r\nconst { APP_PORT: port } = process.env || 8000\r\n\r\n\r\napp.listen(port, () => console.log(`Server started on port ${port}`))\r\nIf your application is still running, TypeScript will recompile your files to Javascript and nodemon will restart the application. If not, start the application using the following command.\r\n\r\nTerminal\r\n\r\nnpm run dev\r\nOpen your browser and navigate to http://127.0.0.1:8000 to open the application. From the home page, select the Clients dropdown, then select the Add New option. You will see the form for adding a new client as shown below.\r\n\r\nAdd new client\r\n\r\nClick on the "Submit" to see all the error messages as shown below.\r\n\r\nField Validation\r\n\r\nFill in the required details, click Submit, and you will be redirected to the list of clients as shown below.\r\n\r\nView client\r\n\r\nYou can test the delete action by clicking the red bin icon.\r\n\r\nConclusion\r\nIn this article, you learned how to build an SSR-enabled Node.js application using Express, Pug, and MySQL. Additionally, you learned how to set up your PlanetScale database via the web application as well as the CLI. As mentioned earlier, it’s a matter of preference. The web application is intuitive and makes it an absolute breeze to manage your database. However, if you love typing and have no problem remembering CLI commands, you’ll find that you can wave your PlanetScale wand as fast as your fingers and mind will allow.\r\n\r\nThe entire codebase is available on GitHub. Happy Coding!\r\n\r\nWant the power of Vitess on your own cloud, but don’t want to manage it yourself?\r\nContact us\r\nShare\r\nNext post\r\nPlanetScale Boost is now available to everyone\r\n\r\nWritten by\r\nOlususi Oluyemi\r\nOlususi Oluyemi\r\nLast updated August 2, 2023\r\nDatabases at Scale Tech Talk\r\nJoin us for this virtual event where we cover the challenges of database scaling plus a deep dive on how Vitess solves these issues.\r\n\r\nRegister now\r\nTable of contents\r\nGetting Started\r\nSetting up PlanetScale Database\r\nCreate a database via the dashboard\r\nCreate a database via CLI\r\nSet up application\r\nConnect the application to PlanetScale\r\nSet up Express\r\nForm validation\r\nController functions\r\nAdd views for client pages\r\nUpdate app.ts\r\nConclusion\r\nRelated posts\r\n\r\nTutorials\r\n\r\nBuild a library app with Laravel 10 and MySQL\r\n\r\nTutorials\r\n\r\nBuild an expense tracker app with Symfony and MySQL\r\n\r\nTutorials\r\n\r\nUsing PlanetScale with Serverless Framework Node applications on AWS\r\nCompany\r\nAbout\r\nBlog\r\nChangelog\r\nCareers\r\nProduct\r\nCase studies\r\nEnterprise\r\nPricing\r\nAI/ML\r\nResources\r\nDocs\r\nLearn\r\nMySQL for Developers\r\nSupport\r\nStatus\r\nOpen Source\r\nVitess\r\nVitess community\r\nGitHub\r\nTalk to us\r\nCall +1 408 214 1997\r\nContact us\r\n© 2024 PlanetScale, Inc. All rights reserved.\r\nPrivacy\r\nTerms\r\nCookies\r\nDo Not Share My Personal Information\r\n', 'Skip to content\r\nProducts\r\nSolutions\r\nResources\r\n\r\nDocumentation\r\nPricing\r\nContact\r\n\r\nSign in\r\nGet started\r\nBlog\r\nTutorials\r\nFollow us\r\nSync user data between Clerk and a PlanetScale MySQL database\r\nLearn how to sync user data from a Clerk project into your PlanetScale MySQL database with webhooks using Netlify and Netlify Functions.\r\n\r\nSync user data between Clerk and a PlanetScale MySQL database\r\nA common strategy of modern development, especially in serverless applications, is to offload user management to third-party authentication services, commonly referred to as Identity Providers (IdP). While this shifts the focus and responsibility of managing your users’ data to another organization, implementing this strategy brings several tradeoffs:\r\n\r\nYou don’t have direct access to user data within your own systems.\r\nYou can’t perform secondary actions when a user changes their data in some way.\r\nAny API calls where the user’s info is used would require you to call the IdP, making the responses take longer.\r\nIn this article, you’ll learn how to address each of these issues using webhooks, a pattern where the IdP can send an HTTP call to your API to inform you of any changes made on their end. To do this, you’ll be using a combination of Clerk, Netlify, and PlanetScale.\r\n\r\nFor the demo, we’ll be using Orbytal.ink, an open-source “link in bio” web application that uses the services listed above. By the end of this guide, Clerk will be configured to send an HTTP request to a Netlify Function designed specifically for accepting these requests whenever a user is created, updated, or deleted.\r\n\r\nTo follow along, make sure you have the following:\r\n\r\nA PlanetScale account and the PlanetScale CLI installed and configured\r\nA GitHub account\r\nA Netlify account\r\nA Clerk account\r\nSet up the project\r\nCreate a PlanetScale database\r\nStart by creating a PlanetScale database using the PlanetScale CLI.\r\n\r\nTerminal\r\n\r\npscale database create orbytalink\r\nNext, create a password for that database. The name is arbitrary but the following command uses “defaultpass”:\r\n\r\nTerminal\r\n\r\npscale password create orbytalink main defaultpass\r\nNote\r\nTake note of the username and password — you’ll be using those values when setting up Netlify.\r\n\r\nNow, open a shell session to the new database you just created:\r\n\r\nTerminal\r\n\r\npscale shell orbytalink main\r\nTo configure the tables for the database, run the following command in the pscale shell session:\r\n\r\nSQL\r\n\r\nCREATE TABLE `users` (\r\n	`id` bigint unsigned PRIMARY KEY AUTO_INCREMENT,\r\n	`username` varchar(120),\r\n	`tagline` varchar(250),\r\n	`display_name` varchar(250),\r\n	`img_url` varchar(500)\r\n);\r\nCREATE TABLE `blocks` (\r\n	`id` bigint unsigned PRIMARY KEY AUTO_INCREMENT,\r\n	`url` varchar(200),\r\n	`type` int,\r\n	`user_id` int,\r\n	`label` varchar(200)\r\n);\r\nNote\r\nFor a high level overview on PlanetScale, check out our Introduction to PlanetScale Tech Talk.\r\n\r\nSet up a Clerk application\r\nHead over to Clerk and create a new application. Make sure to only check "Username" in the "How will your users sign in?" section, then click "Create application".\r\n\r\nCreate a new application in Clerk.\r\n\r\nNext, you’ll have to configure a few more options before the project is properly configured. Select "Users & Authentication" > "Email, Phone, Username" on the left side. Then click the "gear" next to "Email address".\r\n\r\nUpdate the email address setting.\r\n\r\nIn the modal, enable the "Require" option and make sure "Email verification code" is enabled. Everything else should be disabled. Click "Continue" to accept the settings.\r\n\r\nSet email address to required.\r\n\r\nScroll down a bit and enable "Name", then click the "gear icon".\r\n\r\nUpdate the name settings.\r\n\r\nIn the modal, toggle "Require" to on and click "Continue".\r\n\r\nSet name to required.\r\n\r\nScroll to the bottom of the page and click "Apply changes".\r\n\r\nNow you’ll need to grab the API keys for the project so the application will work when deployed. Select "API Keys" on the left and take note of both the "Publishable key" and the "Secret key". You’ll need these values as well when setting up Netlify.\r\n\r\nNote\r\nAnyone who has these values can access your Clerk project, so make sure to keep these values secret!\r\n\r\nGet the Clerk API keys.\r\n\r\nFork the project and deploy to Netlify\r\nNext, log into GitHub and fork the orbytal.ink project to your own account. Make sure "Copy the main branch only" is NOT enabled as you’ll want all branches forked into your account.\r\n\r\nLog into your Netlify account, and click "Add new site" > "Import an existing project".\r\n\r\nCreate a new Netlify site.\r\n\r\nSelect "Deploy with GitHub".\r\n\r\nDeploy with GitHub.\r\n\r\nNext, select "Orbytal.ink" from the list of projects in your account.\r\n\r\nSelect Orbytal.ink in Netlify.\r\n\r\nMake sure to select the clerk-blog-post branch under "Branch to deploy". Then, scroll to the bottom and click "Deploy Orbytal.ink".\r\n\r\nDeploy the clerk-blog-post branch.\r\n\r\nOnce the initial deployment is done, you’ll need to configure a few environment variables. Select "Site configuration" from the sidebar, and then "Environment variables". Add the following variables:\r\n\r\nDATABASE_URL - The connection string for your PlanetScale database formatted as mysql://<DB_USERNAME>:<DB_PASSWORD>@aws.connect.psdb.cloud/orbytalink and replace DB_USERNAME and DB_PASSWORD with the values created earlier in the guide.\r\nCLERK_API_KEY - The private key acquired when configuring the Clerk project.\r\nVITE_CLERK_PUBLISHABLE_KEY - The public key acquired when configuring the Clerk project.\r\nAdd environment variables.\r\n\r\nFinally, re-deploy the project with the new settings by going back to "Deploys", and then "Trigger deploy" > "Deploy site".\r\n\r\nRedeploy the Netlify site.\r\n\r\nTo test that your deployment works, navigate to the URL provided by Netlify and you should see the following if everything was built and deployed correctly.\r\n\r\nDemo site landing page.\r\n\r\nAdd webhooks\r\nNow that your project is up and running, let\'s add the webhook so we can pass specific user information to the PlanetScale database as users are created or updated.\r\n\r\nConfigure Clerk webhooks\r\nIn the overview of the Clerk project, select "Webhooks" from the sidebar, and then "Add endpoint".\r\n\r\nAdd webhook endpoint.\r\n\r\nEnter the "Endpoint URL" formatted as <NETLIFY_URL>/.netlify/functions/clerk_webhook, select the topmost user element under "Message Filtering", and scroll to the bottom and click "Create".\r\n\r\nSet endpoint URL and events.\r\n\r\nCreate and deploy the Netlify Function\r\nNext, you’ll need to create a Netlify Function that will act as the endpoint to receive messages from our Clerk project. Luckily, all of this work can be done directly within GitHub. With the project open in GitHub, start by switching to the clerk-blog-post branch.\r\n\r\nSwitch to clerk-blog-post branch in GitHub.\r\n\r\nClick "Add file" > "Create new file".\r\n\r\nCreate a new file in GitHub.\r\n\r\nName the file functions/clerk_webhook.ts and paste the following into that file. Note the comments in the code that describe what the important parts of the function do.\r\n\r\nTypeScript\r\n\r\n// functions/clerk_webhook.ts\r\nimport { HandlerEvent, HandlerContext } from \'@netlify/functions\'\r\nimport { getDb } from \'./utils/lib\'\r\nimport { blocks, users } from \'./utils/db/schema\'\r\nimport { eq } from \'drizzle-orm\'\r\n// This type describes the structure of the incoming webhook\r\ntype ClerkWebhook = {\r\n  data: {\r\n    first_name: string\r\n    last_name: string\r\n    image_url: string\r\n    username: string\r\n  }\r\n  type: string\r\n}\r\nconst handler = async (event: HandlerEvent, context: HandlerContext) => {\r\n  if (event.body) {\r\n    // 👉 Parse the incomign event body into a ClerkWebhook object\r\n    const webhook = JSON.parse(event.body) as ClerkWebhook\r\n    try {\r\n      const db = getDb()\r\n      // 👉 `webhook.type` is a string value that describes what kind of event we need to handle\r\n\r\n\r\n      // 👉 If the type is "user.updated" the important values in the database will be updated in the users table\r\n      if (webhook.type === \'user.updated\') {\r\n        await db\r\n          .update(users)\r\n          .set({\r\n            display_name: `${webhook.data.first_name} ${webhook.data.last_name}`,\r\n            img_url: webhook.data.image_url\r\n          })\r\n          .where(eq(users.username, webhook.data.username))\r\n      }\r\n\r\n\r\n      // 👉 If the type is "user.created" create a record in the users table\r\n      if (webhook.type === \'user.created\') {\r\n        await db.insert(users).values({\r\n          display_name: `${webhook.data.first_name} ${webhook.data.last_name}`,\r\n          img_url: webhook.data.image_url,\r\n          username: webhook.data.username\r\n        })\r\n      }\r\n\r\n\r\n      // 👉 If the type is "user.deleted", delete the user record and associated blocks\r\n      if (webhook.type === \'user.deleted\') {\r\n        const dbuser = await db.query.users.findFirst({\r\n          where: eq(users.username, webhook.data.username)\r\n        })\r\n        console.log(\'dbuser\', dbuser)\r\n        if (dbuser) {\r\n          await Promise.all([\r\n            db.delete(users).where(eq(users.id, dbuser.id)),\r\n            db.delete(blocks).where(eq(blocks.user_id, dbuser.id))\r\n          ])\r\n        }\r\n      }\r\n\r\n\r\n      return {\r\n        statusCode: 200\r\n      }\r\n    } catch (err) {\r\n      console.error(err)\r\n      return {\r\n        statusCode: 500\r\n      }\r\n    }\r\n  }\r\n}\r\nexport { handler }\r\nClick on "Commit changes" to open a modal. Feel free to add an extended description if you like, and click "Commit changes" in the modal to create the file in the branch.\r\n\r\nCommit new file in GitHub.\r\n\r\nOnce the file is saved, Netlify should automatically deploy the latest version of the web application.\r\n\r\nTest the function\r\nNow that the new code is deployed, we can test the three main operations that were configured in Clerk. Open the web app using the Netlify address and click "Create your profile".\r\n\r\nCreate your profile on the demo site.\r\n\r\nCreate an account using your own email address. When prompted for a verification code, grab it from your email and enter it.\r\n\r\nCreate a user in Clerk.\r\n\r\nNote\r\nIf you get a message stating "The authentication settings are invalid", be sure to double check your configuration in Clerk.\r\n\r\nOnce the account is created, you should be redirected back to your version of Orbytalink asking for some more details. Add a tagline and click "New block". Select "Twitter" and enter your Twitter username. Finally, click "Save".\r\n\r\nAdd user settings.\r\n\r\nYou should be redirected to your profile that not only shows you the tagline and Twitter block but also your name and username you entered into the Clerk sign-up form. That’s because when you created your account, Clerk sent a message to the Netlify Function you created earlier (clerk_webhook.ts) which saved this information into the PlanetScale database.\r\n\r\nUser profile in demo site.\r\n\r\nIf you explore the Netlify function that is used by the home page to retrieve user data, you’ll notice that there are no API calls to Clerk. It grabs information directly from the PlanetScale database and returns it to the React front end.\r\n\r\nTypeScript\r\n\r\n// functions/profiles.ts\r\nimport { HandlerEvent, HandlerContext } from \'@netlify/functions\'\r\nimport { users } from \'./utils/db/schema\'\r\nimport { eq } from \'drizzle-orm\'\r\nimport { createResponse } from \'./utils/netlify_helpers\'\r\nimport { getDb } from \'./utils/lib\'\r\nconst handler = async (event: HandlerEvent, context: HandlerContext) => {\r\n  const { username } = event.queryStringParameters as any\r\n  const db = getDb()\r\n  if (username) {\r\n    const user = await db.query.users.findFirst({\r\n      where: eq(users.username, username),\r\n      with: {\r\n        blocks: true\r\n      }\r\n    })\r\n    return createResponse(200, user)\r\n  } else {\r\n    const user_rows = await db.select().from(users).limit(30)\r\n    return createResponse(200, user_rows)\r\n  }\r\n}\r\nexport { handler }\r\nThe following sequence diagram explains exactly how this overall system works:\r\n\r\nThe user creates an account in Clerk.\r\nClerk sends a message to the Netlify function once the user is created.\r\nNetlify writes that users’ info to the PlanetScale database.\r\nWebhooks sequence diagram.\r\n\r\nUsing this flow, we can utilize Clerk to handle authentication and user management, and still have the users’ information available to us directly in our PlanetScale database!\r\n\r\nConclusion\r\nWebhooks are extremely useful when using third-party systems where you need to be notified if a specific event happens in a place you don’t have full access to. In this guide, I showed you how you can use webhooks to receive user information from an IdP, but that’s only one example where these can be used in a production system.\r\n\r\nHave you used webhooks in your own projects? Let us know on Twitter by tagging @planetscale!\r\n\r\nNote\r\nIf you enjoyed this article, you might also like our comprehensive guide on integrating AWS Lambda functions with PlanetScale.\r\n\r\nShare\r\nNext post\r\nIntroducing PlanetScale Managed on AWS and GCP\r\n\r\nWritten by\r\nBrian Morrison II\r\nBrian Morrison II\r\nLast updated October 20, 2023\r\nDatabases at Scale Tech Talk\r\nJoin us for this virtual event where we cover the challenges of database scaling plus a deep dive on how Vitess solves these issues.\r\n\r\nRegister now\r\nTable of contents\r\nSet up the project\r\nCreate a PlanetScale database\r\nSet up a Clerk application\r\nFork the project and deploy to Netlify\r\nAdd webhooks\r\nConfigure Clerk webhooks\r\nCreate and deploy the Netlify Function\r\nTest the function\r\nConclusion\r\nRelated posts\r\n\r\nTutorials\r\n\r\nEmulating foreign key constraints with Drizzle relationships\r\n\r\nTutorials\r\n\r\nBuild a contacts app with Node, Express, and MySQL\r\n\r\nTutorials\r\n\r\nBuild a library app with Laravel 10 and MySQL\r\nCompany\r\nAbout\r\nBlog\r\nChangelog\r\nCareers\r\nProduct\r\nCase studies\r\nEnterprise\r\nPricing\r\nAI/ML\r\nResources\r\nDocs\r\nLearn\r\nMySQL for Developers\r\nSupport\r\nStatus\r\nOpen Source\r\nVitess\r\nVitess community\r\nGitHub\r\nTalk to us\r\nCall +1 408 214 1997\r\nContact us\r\n© 2024 PlanetScale, Inc. All rights reserved.\r\nPrivacy\r\nTerms\r\nCookies\r\nDo Not Share My Personal Information\r\n');